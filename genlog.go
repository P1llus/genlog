// Package genlog provides a simple API for generating fake log data
// based on customizable templates and patterns.
//
// It can be used either as a library in your Go code or as a CLI tool.
package genlog

import (
	"github.com/P1llus/genlog/pkg/config"
	"github.com/P1llus/genlog/pkg/generator"
)

// Generator represents a log generator instance.
// It provides methods for generating fake log data according
// to the templates and patterns defined in its configuration.
type Generator struct {
	gen *generator.Generator
}

// NewFromConfig creates a new log generator from the provided configuration.
// This is useful when you want to programmatically create a configuration.
//
// Example:
//
//	cfg := &genlog.Config{
//		Templates: []genlog.LogTemplate{
//			{
//				Template: "{{FormattedDate \"2006-01-02T15:04:05.000Z07:00\"}} [INFO] User {{username}} logged in from {{IPV4Address}}",
//				Weight:   1,
//			},
//		},
//		CustomTypes: map[string][]string{
//			"username": {"john", "alice", "bob"},
//		},
//	}
//	gen := genlog.NewFromConfig(cfg)
func NewFromConfig(cfg *config.Config) *Generator {
	return &Generator{
		gen: generator.NewGenerator(cfg),
	}
}

// NewFromFile creates a new log generator by reading configuration from a file.
// This is the simplest way to get started with genlog.
//
// The configuration file should be in YAML format, defining templates and
// optionally custom types.
//
// Example:
//
//	gen, err := genlog.NewFromFile("config.yaml")
//	if err != nil {
//		// handle error
//	}
func NewFromFile(configFile string) (*Generator, error) {
	cfg, err := config.ReadConfig(configFile)
	if err != nil {
		return nil, err
	}

	return &Generator{
		gen: generator.NewGenerator(cfg),
	}, nil
}

// GenerateLogs generates the specified number of logs and writes them to the output file.
// Each line is generated by randomly selecting a template based on the configured weights
// and then populating the template with random values.
//
// Example:
//
//	err := gen.GenerateLogs("output.log", 1000)
//	if err != nil {
//		// handle error
//	}
func (g *Generator) GenerateLogs(outputFile string, count int) error {
	return g.gen.GenerateLogs(outputFile, count)
}

// GenerateLogLine generates a single log line using a randomly selected template.
// This is useful when you want to generate logs programmatically without writing to a file,
// such as when streaming logs directly to another system.
//
// Example:
//
//	logLine, err := gen.GenerateLogLine()
//	if err != nil {
//		// handle error
//	}
//	fmt.Println(logLine)
func (g *Generator) GenerateLogLine() (string, error) {
	return g.gen.GenerateLogLine()
}

// Config provides access to the configuration structures.
// This allows users to create their own configurations programmatically.
//
// The main configuration contains templates, custom types, and an optional seed.
type Config = config.Config

// LogTemplate represents a single log template with its selection weight.
// Templates use the gofakeit template syntax with placeholders like {name}, {email}, etc.
// Custom types defined in the configuration can also be used as placeholders.
type LogTemplate = config.LogTemplate
